##Size estimation: Function Points

Function Point is an algoritmical methodology aimed at estimating the size of a project, basing on a combination of program characteristics, categorized in:

* __Internal Logic Files (ILFs)__, which looks at how the program stores the data
* __External Interface Files (EIFs)__, which looks at the data used by the system but managed by thirdy parts
* __External Inputs (EIs)__, which looks at the elementary operations involved in processing data coming from the users of the system
* __External Outputs (EOs)__, which looks at data generated by the system and destinated to the external environment
* __External Inquiries (EQs)__, which look at elementary input / output operations

In the following paragraphs we are going to provide both the measuring criteria for each of the cathegories and to apply those criteria to the proposed system for PowerEnJoy car sharing. The measuring criteria come from statistical analysis of real projects, which have been normalized and condensed into the given tables.

###Internal Logic Files

####Measuring criteria

<table style="text-align: center;margin-bottom:10px;">
<tr>
<th></th>
<th colspan = "3">Data Elements</th>
</tr>
<tr>
<th>Record elements</th>
<th>1 - 19</th>
<th>20 - 50</th>
<th>51+</th>
</tr>
<tr>
<th>1</th>
<td>Low</td>
<td>Low</td>
<td>Average</td>
</tr>
<tr>
<th>2 - 5</th>
<td>Low</td>
<td>Average</td>
<td>High</td>
</tr>
<tr>
<th>6+</th>
<td>Average</td>
<td>High</td>
<td>High</td>
</tr>
</table>

| Complexity | FPs |
|:----------:|:---:|
| Low        |  7  |
| Average    | 10  |
| Height     | 15  |


####System analysis

In order to measure the FPs for a specific Internal Logic File, we need to analyze the structure of the data contained in it.

* __Account data__  
  This file contains informations about accounts of people interacting with the system, i.e. users and employees. This accounts for 2 record elements. For each account we have a username and a password, then users have a much more detailed representation than employees, and so they are also characterized by name, date of birth, driving licence number and credit card data, which contain owner, number, expiration date and CVV. Overall, this accounts for 9 Data Elements, so this ILF is considered of low complexity.
* __Reservation data__  
  This file contains informations about reservations. For each reservation, we store the reservor user, the reserved car and the creation time. This accounts for 1 Record Element and 3 Data Elements, hence this ILF il considered of low complexity.
* __Ride data__  
  This file contains informations about rides. For each ride, we store the car involved in the ride, its reservor user, the time at which the ride started and the number of passengers that were in the car at the begin of the ride. This accounts for 1 Record Element and 4 Data Elements, hence this ILF is considered of low complexity
* __Car data__  
  This file contains informations about cars. For each car, we store the plate, the battery charge level, the position expressed as a tuple of latitute and longitude, the safe area where the car is parked in and the geographical area where the car is parked in. This accounts for 1 Record Element and 6 Data Elements, hence this ILF is considered of low complexity.
* __Safe area data__  
  This file contains informations about safe areas. There are two types of safe areas: safe parking areas and recharging stations, hence this accounts for 2 Record Types. Each safe area is described by an identifier and the set of polygons which delimit it. Furthermore, recharging stations also need to have the number of plugs specified. This accounts for 3 Data Elements, so this ILF should be considered of low complexity. However, due to the intrinsic complexity of the _multipolygon_ data type, which is used to store the bounding polygon, we decided to consider this as of average complexity (also because data elements refer to elementary data, not to structured data, hence multipolygon violates this hypothesis and we must correct the estimation).
* __Geographical area data__  
  This file contains informations about safe areas. Just like safe areas, each geographical area is described by an identifier and a set of polygons which delimit it. For the very same reasoning done for safe areas, this ILF is of average complexity

Here is a wrap up table

| ILF                    | Complexity | FPs |
|:-----------------------|:----------:|:---:|
| Account data           | Low        | 7   |
| Reservation data       | Low        | 7   |
| Ride data              | Low        | 7   |
| Bill data              | Low        | 7   |
| Car data               | Low        | 7   |
| Safe area data         | Average    | 10  |
| Geographical area data | Average    | 10  |

Overall sum of calculated FPs gives __55 FPs__

###External Interface Files

####Measuring criteria

<table style="text-align: center;margin-bottom:10px;">
<tr>
<th></th>
<th colspan = "3">Data Elements</th>
</tr>
<tr>
<th>Record elements</th>
<th>1 - 19</th>
<th>20 - 50</th>
<th>51+</th>
</tr>
<tr>
<th>1</th>
<td>Low</td>
<td>Low</td>
<td>Average</td>
</tr>
<tr>
<th>2 - 5</th>
<td>Low</td>
<td>Average</td>
<td>High</td>
</tr>
<tr>
<th>6+</th>
<td>Average</td>
<td>High</td>
<td>High</td>
</tr>
</table>

| Complexity | FPs |
|:----------:|:---:|
| Low        |  5  |
| Average    |  7  |
| Height     | 10  |


####System analysis

External Interface Files strongly depends on the system which PowerEnJoy interfaces with. These systems are:

* The external system for address translations, which carries out the geocoding of given addresses
* The external system for map rendering, which displays maps in the user application
* The payment processing system, which is responsible both for credit card data validation and payment processing
* The driving licence validation system, which is responsible for driving licence validation

For each of these systems, we need to analyze the amount of data that pass through the interface

* __Geocoding system__  
  This interaction is fairly simple, as we only send a string (the address to geocode) and get back a tuple of two coordinates (latitute and longitude). This accounts for 2 Record Elements and a overall count of 3 Data Elements, hence this EIF is considered of low complexity.
* __Map retrival system__  
  This interaction is again fairly simple, as we only send a tuple of latitute and longitude on which the map has to be centered and a set of coordinates to highlight on the map, and get back an image. This accounts for 2 Record Elements, and a overall count of 3 Data Elements (even if one of them, we can consider it simple because it's just a list of pairs of floating point numbers). Hence, this EIF is considered of low complexity.
* __Payment processing system__  
  This interaction is not just simple like the two before, as it has to arry out two tasks. For credit card validation, we need to send the credit card parameters (owner, number, CVV and expiration date), and get back a boolean answer. For payment processing, we again need to send credit card parameters plus the amount of the bill to pay, and then get back another boolean value indicating whether the payment was successful or not. Overall, this accounts for 3 Record Elements (credit card validation request, payment request, operation response) and 6 Data Elements. Hence, this EIF can be considered of low complexity again.
* __Driving licence validation system__  
  This interaction is the most simple in this section. We send the driving licence number and the driving licence owner and get back the validity of the licence. Hence, we have 2 Record Elements and an overall count of 3 Data Elements(driving licence owner, number and validity). Hence, this EIF is considered of low complexity.

Here we have a wrap up table

| EIF                | Complexity | FPs |
|:------------------ |:----------:|:---:|
| Geocoding          | Low        |  5  |
| Map retrival       | Low        |  5  |
| Payment processing | Low        |  5  |
| DL validation      | Low        |  5  |

So far, EIF analysis yields a overall sum of __20 FPs__

###External Inputs

####Measuring criteria

<table style="text-align: center;margin-bottom:10px;">
<tr>
<th></th>
<th colspan = "3">Data Elements</th>
</tr>
<tr>
<th>File Types</th>
<th>1 - 4</th>
<th>5 - 15</th>
<th>16+</th>
</tr>
<tr>
<th>0 - 1</th>
<td>Low</td>
<td>Low</td>
<td>Average</td>
</tr>
<tr>
<th>2 - 3</th>
<td>Low</td>
<td>Average</td>
<td>High</td>
</tr>
<tr>
<th>4+</th>
<td>Average</td>
<td>High</td>
<td>High</td>
</tr>
</table>

| Complexity | FPs |
|:----------:|:---:|
| Low        |  3  |
| Average    |  4  |
| Height     |  6  |

####System analysis
In order to compute FPs for External Inputs, we must consider for each input source (e.g. each API exposed to users or external systems) the complexity of the interaction, measured in terms of both the exchanged data and the ILF / EIF it interacts with. The follwing list carries out the analysis for each external input of the system.
The count of the exchanged data is done basing upon the API description carried out in the Design Document.

* __GET /users/{id}/login__  
  This is a fairly simple functionality, as it evolves only the exchange of two data and interacts with only one ILF (the accounts one). Hence we can consider it of low complexity.
* __POST /users/{id}/register__  
  With respect to the previous one, this is a fairly much complext functionality, as it involves the exchange of 9 Data Elements, but interacts with 1 ILF (the accounts one) and 2 EIF (the payment processing system and the driving licence validation system), hence it has to be considered of average complexity.
* __DELETE /users/me/bills__  
  As far as data exchange is concerned, this is a very simple input, as it has no attached data elements (except for the implicit session token). Instead, it must interact with 1 ILF (the bill one) and 1 EIF (the payment processing system). Hence, we can consider it of low complexity
* __POST /users/{id}/reservations__  
  This input requires 2 Data Elements, and interacts with 2 ILF (the user and the car ones, as specified in the DD) and 1 EIF (for address geocoding), so it can be considered of low complexity.
* __PATCH /cars/{plate}/unlock__  
  This input requires 3 Data Elements to be specified, and interacts with only 3 ILF (the user one, in order to ensure that the user is not banned, the reservation one to ensure the user has a reservation for the car, and the ride one, in order to create the ride). So far, we can consider it of low complexity.
* __PATCH /area/geographicals/{id}/split__  
  This input requires 2 Data Elements to be specified, and interacts with only one ILF (the geographical regions one). But if we consider well the required elements, we notice that we have a fairly complex, structured field required. Than, despite the numbers want this input to be classified as of low complexity, we have to classify it as of average complexity, for reasons which have already been explained for ILF related to geographical regions.
* __PATCH /area/geographicals/{id}/merge__  
  This input requires two Data Elements to be specified, and interacts with only 1 ILF (the one concerned in geographical regions storage), hence we can consider it of low complexity. Despite the similarity, the fields of this input are ways simpler than those of previous one.
* __DELETE /area/safes/{id}__  
  This input only require 1 Data Element to be specified, and only interacts with 1 ILF (the one concerned in safe areas storage), hence we can consider it of low complexity
* __POST /area/safes__  
  The analysis of this input is pretty much similar to that of geographical areas split. In fact, we have 2 Data Elements, of which one fairly complex for the very same reasons as before, and we interact only with 1 ILF (again, the one concerned with safe area storage). Hence, for the same rationale, we consider it of average complexity.
* __PATCH /area/safes/{id}__  
  The analysis of this input is identical to that of the previous one, so we consider it of average complexity for the same reasons as before.
* __Car status (message)__  
  This is the only input which uses the messaging API. It is composed of 4 data elements, and only interacts with 1 ILF (the one concerned with car information storage). Hence, we can consider it of low complexity.
* __Payment completion notification__  
  This input comes from the payment processing system when it processes a payment, and 2 data elements: the former tells if the payment was successful or not, and the latter is the identifier of the bill that was requested to be paid. This input involves an interaction with the ILF concerning bills in order to update the status of the bill. Hence, it can be considered of low complexity.

Moreover, we have to consider that each input (except for those belonging to the /users API) requires user credencials validation and user authentication, hence we must consider it in the overall count. We can model it just as a new input which involves the interaction with one ILF (the one concerned with user information storage) and 1 data element (the session token). Hence we can consider it of low complexity.

Here we have a wrap up table

| EI                                   | Complexity | FPs |
|:-------------------------------------|:----------:|:---:|
| GET /users/{id}/login                | low        | 3   |
| POST /users/{id}/register            | average    | 4   |
| DELETE /users/me/bills               | low        | 3   |
| POST /users/{id}/reservations        | low        | 3   |
| PATCH /cars/{plate}/unlock           | low        | 3   |
| PATCH /area/geographicals/{id}/split | average    | 4   |
| PATCH /area/geographicals/{id}/merge | low        | 3   |
| DELETE /area/safes/{id}              | low        | 3   |
| POST /area/safes                     | average    | 4   |
| PATCH /area/safes/{id}               | average    | 4   |
| Car status message                   | low        | 3   |
| Payment completion notification      | low        | 3   |
| User authentication                  | low        | 3   |

From the table above, EIs analysis yields a result of __43 FPs__.

###External Outputs
####Measuring criteria

<table style="text-align: center;margin-bottom:10px;">
<tr>
<th></th>
<th colspan = "3">Data Elements</th>
</tr>
<tr>
<th>File Types</th>
<th>1 - 5</th>
<th>6 - 19</th>
<th>20+</th>
</tr>
<tr>
<th>0 - 1</th>
<td>Low</td>
<td>Low</td>
<td>Average</td>
</tr>
<tr>
<th>2 - 3</th>
<td>Low</td>
<td>Average</td>
<td>High</td>
</tr>
<tr>
<th>4+</th>
<td>Average</td>
<td>High</td>
<td>High</td>
</tr>
</table>

| Complexity | FPs |
|:----------:|:---:|
| Low        |  4  |
| Average    |  5  |
| Height     |  7  |


####System analysis
The system sometimes need to communicate with the external environment outside the context of an inquiry, and this is where External Output comes in. To evaluate the complexity of each external output, we must consider how many ILF or EIF the output is produced from, and the data elements which the output carries in. Here is a list of all the external outputs.

* __Ride duration__  
  This output is produced on the display on board of the cars in order to inform the driver about how is the ride lasting. It only carries one data element (actually, the difference between two timestamps, the actual one and that one the ride begun at), and has to interact with one ILF (the one that stores data about rides). Hence, it can be considered of low complexity (4 FPs).
* __Lock (message)__  
  This output is an async message sent over the message-driven architecture. It has no payload, but needs to interact with 1 ILF (the one concerning data about cars, in order to know where car has stopped). Hence it can be considered of low complexity (4 FPs).
* __Unlock (message)__  
  Just like the previous one, this output is a message sent over the messaging API. It still have no payload, and need to interact with only one ILF (the one concerning reservations), hence we can consider it of low complexity (4 FPs).
* __Payment processing request__  
  This output sends to the payment processing system a request to carry out a payment (and a payment is described by the amount to pay and the credit card data to get this amount from, so other 4 data elements, which are the credit card owner, number, CVV and expiration date). It must deal with 2 ILF (the one concerning bills for the bill to pay and the one concerning users for the credit card data) and 1 ELF (the one concerning payment processing). Hence we can consider it of low complexity (even if it is quite a borderline classification)


The analysis of External Outputs yields an overall result of __16 FPs__.

###External Inquiries

####Measuring criteria

<table style="text-align: center;margin-bottom:10px;">
<tr>
<th></th>
<th colspan = "3">Data Elements</th>
</tr>
<tr>
<th>File Types</th>
<th>1 - 5</th>
<th>6 - 19</th>
<th>20+</th>
</tr>
<tr>
<th>0 - 1</th>
<td>Low</td>
<td>Low</td>
<td>Average</td>
</tr>
<tr>
<th>2 - 3</th>
<td>Low</td>
<td>Average</td>
<td>High</td>
</tr>
<tr>
<th>4+</th>
<td>Average</td>
<td>High</td>
<td>High</td>
</tr>
</table>

| Complexity | FPs |
|:----------:|:---:|
| Low        |  3  |
| Average    |  4  |
| Height     |  6  |


####System analysis
As the system is built mainly with a client-server architectural style, there are many external inputs that require a response by the system which sents him some requested data. The difference with external input is mainly that in the context of an inquiry the server replies with an answer to question of the user without updating his internal status, rather than executing a user command in order to alter its internal status, like in external inputs. 

In order to evaluate the complexity of an inquiry, we must understand which files it references and how many data elements are exchanged during both the request and the response phases.

Here is a list of all the inquiries, including those that involve thirdy part systems.

* __GET /users/{id}/bills__  
  This is a fairly simple inquiry, it involves only 1 data element in the input side and an array of tuples of 2 data element in the output side. As of files, it only interacts with 1 ILF (the one dealing with bills). Hence, we can consider it of low complexity.
* __GET /users/{id}/reservations__  
  This is a fairly complex inquiry, it involves 4 data element in the input side and an array of tuples of 4 data elements in the output side. Moreover, it has to interact with 1 ILF in order to carry out the task. However, it can still be considered of low complexity
* __GET /users/{id}/reservations/{plate}__  
  This inquiry requires 2 data elements in the input side and 4 data elements in the output side, and still has to interact with only 1 ILF (the one concerning reservations), hence it can be considered of low complexity.
* __GET /cars__  
  This inquiry is fairly complex for the amout of data elements involved, as it involves 5 data elements in the input side and an array of tuples of 7 data elements in the output side. However, it only interacts with 1 ILF (the one concerning cars), and thus it can be considered of low complexity.
* __GET /cars/{plate}__  
  This inquiry is similar to the previous one, except for that the input side only requires 1 data element instead of 5. Still, we can consider it of low complexity.
* __GET /area/geographicals__  
  The complex part of this inquiry is the output side. In fact, the input side requires no parameter, and as far as files are concerned, it only interacts with one file, the one concerning the storage of geographical regions. The output side is instead quite complex, as it is constituited by a list of areas, which are consitituted by sets of paths delimiting them, plus a few other data elements. For these reasons we can consider it of average complexity, just like we did in the whole analysis of FPs when we have to deal with data involving paths and polygons.
* __GET /area/geographicals/{id}__  
  Very similar to the previous one, this inquiry requires an input parameter instead of 0 and outputs only one region instead of a list. However, we still have to deal with paths and polygons like before, hence the complexity of this inquiry is still average.
* __GET /area/safes__  
  This inquiry is again similar to the _GET /area/geographicals_ one, except that it deals with safe areas instead of geographical areas. Still, it has no data element in input, a quite complex output, as it is differs only for a few data elements from the previous one, and involves only one ILF (the one that deals with safe areas). Again, this is a functionality of average complexity.
* __GET /area/safes/{id}__  
  This inquiry, like the previous one, can be analyzed in the very same way of _GET /area/geographicals/{id}_. Hence we can consider it again of average complexity.
* __Driving licence validation__  
  This inquiry requires as input the driving licence owner and number, and yields as output the validity of the given licence. It deals with only one EIF (the one concerning driving licence validation). Hence we can consider it of low complexity.
* __Address geocoding__  
  This inquiry requires as input the only address to geocode, and yields as output the latitute and longitude of the given address. So far, it only deals with 3 data elements and 1 EIF (the one concerning geocoding), hence we can consider it of low complexity.
* __Map retrival__  
  This inquiry requires only a tuple of latitute and longitude, plus a number of tuples of latitude and longitude to highlight on the map. As these points are usually position of cars, we can consider that it interacts with 1 ILF (the one concerning cars), 1 EIF (the one concerning map retrival) and 3 data elements, of which one is a structured one. Hence, we can consider it of average complexity.
* __Credit card validation__  
  This inquiry requires in the input side 4 data elements (credit card owner, number, CVV and expiration date), and yields as output only 1 data element indicating whether the credit card is valid or not. It deals with 1 EIF (the one concerning payments processing). Hence, we can consider it of low complexity.

Just like for external inputs, we should consider the user authentication, but we can just take advantage of the functionality presented in the external inputs section and avoid counting it another time in this context.

Here is a summarizing table

| EQ                                   | Complexity | FPs |
|:-------------------------------------|:----------:|:---:|
| GET /users/{id}/bills                | low        | 3   |
| GET /users/{id}/reservations         | low        | 3   |
| GET /users/{id}/reservations/{plate} | low        | 3   |
| GET /cars                            | low        | 3   |
| GET /cars/{plate}                    | low        | 3   |
| GET /area/geographicals              | average    | 4   |
| GET /area/geographicals/{id}         | average    | 4   |
| GET /area/safes                      | average    | 4   |
| GET /area/safes/{id}                 | average    | 4   |
| Driving licence validation           | low        | 3   |
| Address geocoding                    | low        | 3   |
| Map retrival                         | average    | 4   |
| Credit card validation               | low        | 3   |

Overall sum of calculated FPs gives __44 FPs__.


###Overall analysis

The following table summarizes the FPs analysis.

| Function type        | FPs |
|:---------------------|:---:|
| Internal logic files |  55 |
| External logic files |  20 |
| External inputs      |  43 |
| External outputs     |  16 |
| External inquiries   |  44 |
| TOTAL                | 178 |

Considering Java Enterprise Edition as the deployment environment and ignoring the HTML, JavaScript involved in user and employee applications (which is just a very small part if compared to the server logic and the data structure development, and can be thought as presentation logic only, with no business logic in it), we can get an approximation about the number of line of code that this project will require.

Average approximation:
~~~
SLOC = 178 × 46 = 8188
~~~
Conservative approximation:
~~~
SLOC = 178 × 67 = 11926
~~~

The conversion rates are statistically derived from real projects.